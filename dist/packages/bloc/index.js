"use strict";var B=Object.defineProperty;var M=(a,e,t)=>e in a?B(a,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):a[e]=t;var n=(a,e,t)=>(M(a,typeof e!="symbol"?e+"":e,t),t);Object.defineProperty(exports,Symbol.toStringTag,{value:"Module"});const m=require("rxjs");class j{constructor(e,t){this.current=e,this.nextState=t}}const d=class d{static get observer(){return d._observer}static set observer(e){C()||(d._observer=e)}onCreate(e,t){}onEvent(e,t){}onTransition(e,t){}onError(e,t){}onChange(e,t){}onClose(e){}};n(d,"_observer",new d);let u=d;class g{constructor(e,t){n(this,"name");n(this,"state$");n(this,"subscriptions",new Set);n(this,"_isClosed",!1);n(this,"_emitted",!1);n(this,"_state");n(this,"_stateSubject$");this._state=e,this._stateSubject$=new m.Subject,this.state$=this._stateSubject$.asObservable(),this.name=t??this.constructor.name,this.subscriptions.add(this.state$.subscribe()),u.observer.onCreate(this,this._state)}get state(){return this._state}get isClosed(){return this._isClosed}onError(e){u.observer.onError(this,e)}onChange(e){u.observer.onChange(this,e)}onClose(){u.observer.onClose(this)}addError(e){this.onError(e)}listenTo(e,t){let s;typeof t=="function"?s={next:t}:s=t;const r={next:i=>{var c;(c=s.next)==null||c.call(this,i)},error:i=>{var c;(c=s.error)==null||c.call(this,i)},complete:()=>{var i;(i=s.complete)==null||i.call(this)}},h=e.subscribe(r);return this.subscriptions.add(h),{unsubscribe:()=>{h.unsubscribe(),this.subscriptions.delete(h)},get isClosed(){return h.closed}}}__unsafeEmit__(e){return this.emit(e)}emit(e){try{if(this._isClosed&&console.warn("Cannot emit new states after calling close"),e==this._state&&this._emitted)return;const t=this.state;this._state=e,this.onChange(new j(t,e)),this._stateSubject$.next(e),this._emitted=!0}catch(t){throw this.onError(t),t}}fromJson(e){return JSON.parse(e)}toJson(e){return JSON.stringify(e)}close(){this._isClosed=!0,this._stateSubject$.complete(),this.subscriptions.forEach(e=>e.unsubscribe()),this.subscriptions.clear(),this.onClose()}}class y{constructor(e){n(this,"_disposables",[]);this._emit=e}call(e){return this._emit(e)}onEach(e,t,s){return new Promise((r,h)=>{const i=e.subscribe({next:t,error:c=>{s?(s(c),r()):h()},complete:r});this._disposables.push(i)})}forEach(e,t,s){return this.onEach(e,r=>this._emit(t(r)),s?r=>this._emit(s(r)):void 0)}close(){this._disposables.forEach(e=>e.unsubscribe()),this._disposables=[]}}class v extends Error{constructor(e){super(e),Object.setPrototypeOf(this,v.prototype)}}class T{constructor(e,t,s){this.currentState=e,this.event=t,this.nextState=s}}const E=class E extends g{constructor(t,s){super(t,s==null?void 0:s.name);n(this,"_eventSubject$",new m.Subject);n(this,"_eventMap",new WeakSet);n(this,"_eventStateMappers",new Array);n(this,"_globalTransformer");n(this,"_emitters",new Set);n(this,"isBlocInstance",!0);if(this.on=this.on.bind(this),this.add=this.add.bind(this),this.emit=this.emit.bind(this),this._globalTransformer=s==null?void 0:s.transformer,this._globalTransformer){const h=this._globalTransformer(this._eventSubject$,i=>this._eventStateMappers.find(c=>c.filter(i)).mapper(i)).subscribe();this.subscriptions.add(h)}}static transformer(){return(t,s)=>t.pipe(m.mergeMap(s))}onError(t){u.observer.onError(this,t)}onTransition(t){u.observer.onTransition(this,t)}onEvent(t){u.observer.onEvent(this,t)}on(t,s,r){if(this._eventMap.has(t))throw new $(`${t.name} can only have one EventHandler`);if(this._globalTransformer&&r)throw new Error("Can't provide a transformer for invididuals events along with a bloc-level event transformer");if(this.hasAncestor(t,!0))throw new $(`${t.name} can only have one EventHandler per hierarchy`);this._eventMap.add(t);const h=i=>{const c=new m.Subject;let f=!1;const S=o=>{if(!f&&!(this.state===o&&this._emitted))try{const l=this.state;this.onTransition(new T(l,i,o)),c.next(o)}catch(l){throw this.onError(l),l}},b=new y(S.bind(this)),_=o=>b.call(o);Object.defineProperty(_,"isClosed",{get:()=>f}),_.onEach=(o,l,w)=>b.onEach(o,l,w),_.forEach=(o,l,w)=>b.forEach(o,l,w);const x=async()=>{try{this._emitters.add(b),await s.call(this,i,_)}catch(o){throw this.onError(o),o}};return new m.Observable(o=>(c.subscribe(this.emit),x().then(()=>o.complete()).catch(l=>o.error(l)),()=>{f=!0,b.close(),this._emitters.delete(b),c.complete()}))};if(this._globalTransformer)this._eventStateMappers.push({filter:i=>i instanceof t,mapper:h});else{const f=(r??E.transformer())(this._eventSubject$.pipe(m.filter(S=>S instanceof t)),h).subscribe();this.subscriptions.add(f)}}hasAncestor(t,s=!1){let r=Object.getPrototypeOf(t);return s||(r=r.constructor),this._eventMap.has(r)?!0:r===null?!1:this.hasAncestor(r,!0)}add(t){if(!this.hasAncestor(t))throw new v(`
        add(${t}) was called without a registered event handler.
        Make sure to register a handler via on(${t}, (event, emit) {...})
      `);try{this.onEvent(t),this._eventSubject$.next(t)}catch(s){throw this.onError(s),s}return this}close(){this._emitters.forEach(t=>t.close()),this._emitters.clear(),this._eventSubject$.complete(),super.close()}};n(E,"ignoreListeners",!1);let p=E;const O=a=>a instanceof p||!!a.isBlocInstance;class $ extends Error{constructor(){super(...arguments);n(this,"name","BlocError")}}class I extends g{constructor(e,t){super(e,t)}}const C=()=>typeof window>"u",A=()=>!C();exports.Bloc=p;exports.BlocBase=g;exports.BlocObserver=u;exports.Change=j;exports.Cubit=I;exports.EmitterImpl=y;exports.StateError=v;exports.Transition=T;exports.isBlocInstance=O;exports.isClient=A;exports.isServer=C;
