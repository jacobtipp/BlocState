"use strict";var T=Object.defineProperty;var y=(o,t,e)=>t in o?T(o,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):o[t]=e;var i=(o,t,e)=>(y(o,typeof t!="symbol"?t+"":t,e),e);Object.defineProperty(exports,Symbol.toStringTag,{value:"Module"});const d=require("rxjs");class S{constructor(t,e){this.current=t,this.nextState=e}}class f extends Error{constructor(t){super(t),Object.setPrototypeOf(this,f.prototype)}}class w{constructor(t,e){i(this,"name");i(this,"state$");i(this,"subscriptions",new Set);i(this,"_isClosed",!1);i(this,"_emitted",!1);i(this,"_state");i(this,"_stateSubject$");this._state=t,this._stateSubject$=new d.Subject,this.state$=this._stateSubject$.asObservable(),this.name=e??this.constructor.name,this.subscriptions.add(this.state$.subscribe()),u.observer.onCreate(this,this._state)}get state(){return this._state}get isClosed(){return this._isClosed}onError(t){u.observer.onError(this,t)}onChange(t){u.observer.onChange(this,t)}onClose(){u.observer.onClose(this)}addError(t){this.onError(t)}listenTo(t,e){let s;typeof e=="function"?s={next:e}:s=e;const c={next:r=>{var a;(a=s.next)==null||a.call(this,r)},error:r=>{var a;(a=s.error)==null||a.call(this,r)},complete:()=>{var r;(r=s.complete)==null||r.call(this)}},h=t.subscribe(c);return this.subscriptions.add(h),{unsubscribe:()=>{h.unsubscribe(),this.subscriptions.delete(h)},get isClosed(){return h.closed}}}__unsafeEmit__(t){return this.emit(t)}emit(t){try{if(this._isClosed)throw new f("Cannot emit new states after calling close");if(t==this._state&&this._emitted)return;const e=this.state;this._state=t,this._stateSubject$.next(t),this.onChange(new S(e,t)),this._emitted=!0}catch(e){throw this.onError(e),e}}fromJson(t){return JSON.parse(t)}toJson(t){return JSON.stringify(t)}close(){this._isClosed=!0,this._stateSubject$.complete(),this.subscriptions.forEach(t=>t.unsubscribe()),this.subscriptions.clear(),this.onClose()}}class g{onCreate(t,e){}onEvent(t,e){}onTransition(t,e){}onError(t,e){}onChange(t,e){}onClose(t){}}class C{constructor(t){i(this,"_disposables",[]);this._emit=t}call(t){return this._emit(t)}onEach(t,e,s){return new Promise((c,h)=>{const r=t.subscribe({next:e,error:a=>{s?(s(a),c()):h()},complete:c});this._disposables.push(r)})}forEach(t,e,s){return this.onEach(t,c=>this._emit(e(c)),s?c=>this._emit(s(c)):void 0)}close(){this._disposables.forEach(t=>t.unsubscribe()),this._disposables=[]}}class ${constructor(t,e,s){this.currentState=t,this.event=e,this.nextState=s}}const b=class b extends w{constructor(e,s){super(e,s==null?void 0:s.name);i(this,"_eventSubject$",new d.Subject);i(this,"_eventMap",new WeakMap);i(this,"_eventStateMappers",new Array);i(this,"_globalTransformer");i(this,"_emitters",new Set);i(this,"isBlocInstance",!0);if(this.on=this.on.bind(this),this.add=this.add.bind(this),this.emit=this.emit.bind(this),this._globalTransformer=s==null?void 0:s.transformer,this._globalTransformer){const h=this._globalTransformer(this._eventSubject$,r=>this._eventStateMappers.find(a=>a.filter(r)).mapper(r)).subscribe();this.subscriptions.add(h)}}static transformer(){return(e,s)=>e.pipe(d.mergeMap(s))}onError(e){b.observer.onError(this,e)}onTransition(e){b.observer.onTransition(this,e)}onEvent(e){b.observer.onEvent(this,e)}on(e,s,c){if(this._eventMap.has(e))throw new Error(`${e.name} can only have one EventHandler`);if(this._globalTransformer&&c)throw new Error("Can't provide a transformer for invididuals events along with a bloc-level event transformer");this._eventMap.set(e,1);const h=r=>{const a=new d.Subject;let _=!1;const E=n=>{if(!_&&!(this.state===n&&this._emitted))try{const l=this.state;a.next(n),this.onTransition(new $(l,r,n))}catch(l){throw this.onError(l),l}},m=new C(E.bind(this)),p=n=>m.call(n);Object.defineProperty(p,"isClosed",{get:()=>_}),p.onEach=(n,l,v)=>m.onEach(n,l,v),p.forEach=(n,l,v)=>m.forEach(n,l,v);const j=async()=>{try{this._emitters.add(m),await s.call(this,r,p)}catch(n){throw this.onError(n),n}};return new d.Observable(n=>(a.subscribe(this.emit),j().then(()=>n.complete()).catch(l=>n.error(l)),()=>{_=!0,m.close(),this._emitters.delete(m),a.complete()}))};if(this._globalTransformer)this._eventStateMappers.push({filter:r=>r instanceof e,mapper:h});else{const _=(c??b.transformer())(this._eventSubject$.pipe(d.filter(E=>E instanceof e)),h).subscribe();this.subscriptions.add(_)}}add(e){if(!this._eventMap.has(Object.getPrototypeOf(e).constructor))throw new f(`
        add(${e}) was called without a registered event handler.
        Make sure to register a handler via on(${e}, (event, emit) {...})
      `);try{this.onEvent(e),this._eventSubject$.next(e)}catch(s){throw this.onError(s),s}return this}close(){this._emitters.forEach(e=>e.close()),this._emitters.clear(),super.close()}};i(b,"observer",new g);let u=b;const B=o=>o instanceof u||!!o.isBlocInstance;class M extends w{constructor(t,e){super(t,e)}}exports.Bloc=u;exports.BlocBase=w;exports.BlocObserver=g;exports.Change=S;exports.Cubit=M;exports.EmitterImpl=C;exports.StateError=f;exports.Transition=$;exports.isBlocInstance=B;
